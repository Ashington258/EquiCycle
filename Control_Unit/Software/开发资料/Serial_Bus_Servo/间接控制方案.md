!--
 * @Author: 小叶同学
 * @Date: 2024-03-21 10:29:40
 * @LastEditors: Please set LastEditors
 * @LastEditTime: 2024-03-21 10:29:44
 * @Description: 请填写简介
-->

>参考：https://blog.csdn.net/weixin_51914644/article/details/127864886
#### 全双工串口、半双工串口总线及其转换

+   +   +   [前言](#_3)
        +   [全双工串口](#_5)
        +   [半双工串口总线](#_13)
        +   [两者转换](#_21)
        +   +   +   [软硬件配合方案](#_26)
                +   [纯电路方案](#_32)

#### 前言

这是本人在接触串口总线时的一些总结，希望能对大家有所帮助，若有谬误之处，恳请各位指正。

#### 全双工串口

全双工串口是非常常见的一种串口，在此不过多介绍。  
在物理上，其最简单的组成为 GND、TX、RX 三根线，其中 TX 通常使用 **推挽输出**，对高电平和低电平的驱动能力均较强，常见实现为下图的 CMOS 逻辑和 TTL 逻辑。

![推挽电路](https://img-blog.csdnimg.cn/3fc9ca8b64ba4ac2b9ce639309fbc4b2.png)

#### 半双工串口总线

相比全双工串口，半双工串口总线仅使用一条数据线，数据在该线上可以双向流动，各设备连在一条总线上，可以 **从总线获取来自其他设备的数据** 或 **驱动总线向其他设备发送数据**，由于各设备均能驱动总线，因此为了防止竞争电平，总线往往采用 **线与** 的形式，即仅当没有任何设备驱动总线至低电平时总线才能保持高电平，而只要任一设备驱动至低电平则总线就为低电平。  
这要求挂在在总线上的设备均为 **开漏输出**，即只有对低电平的驱动能力，而当输出高时则保持高阻态，不驱动总线，由总线上的上拉电阻将总线拉高。  
下图展示了总线的驱动形式，Q1 ~ Q4 代表了 4 个设备对总线的驱动，只有它们全部关断，总线才为高电平。

![总线驱动形式](https://img-blog.csdnimg.cn/6e987319d39845c68ba9ef342910e5eb.png)  
有了上面的电路形式，即使某一设备输出高，而同时另一设备输出低，也不会引起竞争电平，即不会短路造成电路故障。诚然，由于此时总线电平为低，输出高的设备的输出无效了，会导致数据的丢失。因此总线上不应有两个设备同时发送数据，这涉及总线仲裁的问题，在此不详细讨论。

#### 两者转换

在单片机上，我们一般接触到的是全双工串口，虽然像 STM32 的有些芯片的串口也支持单线半双工模式，但此处不研究，主要讨论如何使用全双工串口的 TX、RX 驱动串口总线 BUS。  
对比两种串口的区别并考虑到我们的目的，我们主要需要解决两个问题：  
① 输出必须是开漏输出。  
② 从总线接收的数据应当是其他设备的而不是自己的，即不应产生环回。

###### 软硬件配合方案

若单片机的功能支持且配置比较容易的话，我们可进行以下操作：  
① 将单片机的 TX、RX 接在一起，并接到 BUS 上，并为 BUS 连接合适的上拉电阻。  
② 将 TX 配置为开漏输出。  
③ 每次发送数据前屏蔽串口数据接收，如关闭串口中断，发送完成后再开启。  
这一方案电路简单，但软件上的操作麻烦，当需要频繁发送数据时比较耗损性能。

###### 纯电路方案

对于我们要设计的转换电路，除了供电和地，它应有 TX、RX 和 BUS 三个接口，注意此处的 TX、RX 是对转换电路这一主体而言的，BUS 上的信号会被发到 TX 上送出转换电路，RX 接收外来信号，发到 BUS 上去。  
① 为满足 BUS 必须是开漏的要求，我们应 *阻止来自 RX 的推挽的高电平，转而将其变为高阻态*。  
② 为满足避免数据环回的要求，我们要防止 RX 接收的信号再通过 TX 发回去，考虑到串口的空闲电平为高电平，那么就是要 *对 TX 屏蔽 RX 所接到的低电平信号*。

结合上述分析，我们可以使用 **可控的三态输出的数据缓冲器** 来满足这一需求，如下图：

![简化原理图](https://img-blog.csdnimg.cn/6a8a04e3725e4c99a4185f0df4f65e55.png)  
其中 NOT\_RX 即为 ~RX，当 RX 为高电平，NOT\_RX 为低，U1A 不工作，输出高阻态，BUS 由 R1 上拉至高电平；当 RX 收到低电平，NOT\_RX 为高，U1A 工作，BUS 变为低电平，但 U1B 不工作，TX 不受影响；当 RX 保持高电平时若 BUS 有来自其他设备的信号，变为低电平，而由于此时 U1B 工作，则能正常传输到 TX。  
上图为方便解释，较为简化，下图则更为完整。其中 U1C 为常使能状态，主要起提高 RX 来的信号的驱动能力的作用。

![原理图](https://img-blog.csdnimg.cn/1b0d471eb2de470ebdc06ce0a141c2ac.png)  
为搭建此电路，可使用 **74HC126D** 这一芯片，这是一个包含 4 个可控的三态输出的数据缓冲器的芯片。其输入包括箝位二极管，这使得能够使用限流电阻将输入连接到超过 VCC 的电压。  
其引脚分布如下图：  
![引脚分布](https://img-blog.csdnimg.cn/a5673fdbef29414ab2673528d89bf8fa.png)

对于电路中的反相器，可使用反相器芯片，也可使用源极接地的 NMOS 结合上拉电阻的方式实现，也可以将 74HC126D 的其中一个数据缓冲器的 A 接地，当成源极接地的 NMOS 再结合上拉电阻实现。

这一纯电路方案在至少 115200 波特率的条件下可以正常工作，更高速度尚未测试，对于波特率极高的情况下，则应当更严格地考虑器件的响应速度等因素，并进行大量数据收发的测试。

附一种我认为比较便于布线的连接方式，仅供参考：  
![连接方式](https://img-blog.csdnimg.cn/2c3e89181d9f4f7fac300784d82db6c0.png)  
这一连接方式把反相器的位置提前了，使 RX 的信号同时进入缓冲器和反相器，个人认为这将更有利于正向和反向信号的同步，防止经反相器后的信号在时间上落后过多。当然，从芯片手册来看，OE 端输入的延迟要高于 A 端输入的延迟，因此经反相器的信号应该仍然有所落后，在此暂且不详细讨论。